<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>المنصة البحثية للبيانات المناخية</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #map { height: 100vh; width: 100%; }
        
        /* تصميم لوحة التحكم */
        .sidebar {
            position: absolute; top: 10px; right: 10px; bottom: 10px; width: 300px;
            background: white; z-index: 1000; padding: 20px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1); border-radius: 8px;
            overflow-y: auto; display: flex; flex-direction: column; gap: 15px;
        }
        
        h2 { font-size: 18px; color: #2c3e50; margin: 0; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        label { font-size: 14px; font-weight: bold; color: #555; margin-bottom: 5px; display: block; }
        
        input, select {
            width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px;
            font-size: 14px; box-sizing: border-box;
        }
        
        button {
            width: 100%; padding: 12px; background-color: #27ae60; color: white;
            border: none; border-radius: 5px; cursor: pointer; font-weight: bold;
            transition: 0.3s;
        }
        button:hover { background-color: #219150; }
        button:disabled { background-color: #95a5a6; cursor: not-allowed; }
        
        .alert {
            padding: 10px; background: #e8f6f3; color: #1abc9c; border-radius: 5px;
            font-size: 13px; border: 1px solid #d1f2eb; display: none;
        }
        
        .legend {
            line-height: 18px; color: #555; background: white; padding: 10px;
            border-radius: 5px; box-shadow: 0 0 15px rgba(0,0,0,0.2);
            position: absolute; bottom: 30px; left: 30px; z-index: 1000;
            display: none;
        }
        .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.7; }
        
        /* مؤشر التحميل */
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 20px; height: 20px; animation: spin 2s linear infinite;
            margin: 10px auto; display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div class="sidebar">
    <h2>إعدادات التحليل المكاني</h2>
    
    <div id="step1" style="background:#f9f9f9; padding:10px; border-radius:5px;">
        <label>1. تحديد منطقة الدراسة:</label>
        <p style="font-size:12px; margin:5px 0;">استخدم أدوات الرسم (المربع أو المضلع) على الخريطة لتحديد المجال.</p>
    </div>

    <div>
        <label for="yearInput">2. السنة:</label>
        <input type="number" id="yearInput" min="1950" max="2023" value="2022">
    </div>

    <div>
        <label for="variableSelect">3. نوع البيانات:</label>
        <select id="variableSelect">
            <option value="temp">درجة الحرارة (Mean Temperature)</option>
            <option value="rain">التساقطات المطرية (Total Precipitation)</option>
        </select>
    </div>

    <button id="analyzeBtn" onclick="runAnalysis()">ابدأ التحليل</button>
    <div class="loader" id="loader"></div>
    <div id="statusMsg" style="text-align: center; font-size: 13px; color: #666; margin-top:5px;"></div>
    
    <div class="alert" id="resultStats"></div>
</div>

<div id="legend" class="legend"></div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

<script>
    // 1. تهيئة الخريطة
    const map = L.map('map').setView([31.7917, -7.0926], 6); // المغرب
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: 'OpenStreetMap, Open-Meteo, Leaflet'
    }).addTo(map);

    // 2. إعداد أدوات الرسم (Leaflet Draw)
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
        draw: {
            polyline: false, circle: false, marker: false, circlemarker: false,
            polygon: { allowIntersection: false, showArea: true },
            rectangle: { showArea: true }
        },
        edit: { featureGroup: drawnItems }
    });
    map.addControl(drawControl);

    // متغير لتخزين المضلع الذي رسمه المستخدم
    let userPolygon = null;
    let resultLayer = null;

    // عند الانتهاء من الرسم
    map.on(L.Draw.Event.CREATED, function (e) {
        drawnItems.clearLayers(); // مسح أي رسم قديم
        const layer = e.layer;
        drawnItems.addLayer(layer);
        userPolygon = layer.toGeoJSON(); // تحويل الرسم إلى GeoJSON
        document.getElementById('statusMsg').innerText = "تم تحديد المجال. الآن اختر السنة واضغط تحليل.";
        document.getElementById('statusMsg').style.color = "green";
    });

    // 3. الدالة الرئيسية للتحليل
    async function runAnalysis() {
        const btn = document.getElementById('analyzeBtn');
        const loader = document.getElementById('loader');
        const status = document.getElementById('statusMsg');
        const year = document.getElementById('yearInput').value;
        const variable = document.getElementById('variableSelect').value;

        if (!userPolygon) {
            alert("المرجو رسم مجال الدراسة (Polygon) على الخريطة أولاً.");
            return;
        }

        // تنظيف النتائج السابقة
        if (resultLayer) map.removeLayer(resultLayer);
        document.getElementById('legend').style.display = 'none';
        document.getElementById('resultStats').style.display = 'none';

        // بدء التحميل
        btn.disabled = true;
        loader.style.display = 'block';
        status.innerText = "جاري توليد نقاط العينة...";

        try {
            // أ. توليد نقاط داخل المضلع (Sampling)
            // نحسب مساحة المضلع لتحديد كثافة النقاط المناسبة
            const area = turf.area(userPolygon) / 1000000; // كم مربع
            let cellSide = 10; // المسافة بين النقاط بالكيلومتر
            
            // ضبط دقة الشبكة حسب حجم المنطقة لتفادي الضغط على السيرفر
            if (area > 10000) cellSide = 50;
            else if (area > 5000) cellSide = 30;
            else if (area > 1000) cellSide = 15;
            
            // إنشاء BBox للمضلع
            const bbox = turf.bbox(userPolygon);
            // إنشاء شبكة نقاط تغطي المنطقة
            const grid = turf.pointGrid(bbox, cellSide, {units: 'kilometers', mask: userPolygon});
            
            // تحديد حد أقصى للنقاط (مثلاً 50 نقطة) للحفاظ على سرعة المتصفح
            // في النسخة الإنتاجية يمكن رفع هذا الرقم
            const features = grid.features.slice(0, 60);

            if (features.length === 0) throw new Error("المجال صغير جداً، حاول توسيع المنطقة.");

            status.innerText = `جاري سحب بيانات سنة ${year} من الأرشيف لـ ${features.length} موقع...`;

            // ب. جلب البيانات التاريخية
            const processedPoints = await fetchHistoricalData(features, year, variable);

            status.innerText = "جاري المعالجة والاستقراء...";

            // ج. تنفيذ الاستقراء (Interpolation)
            const interpolatedGrid = turf.interpolate(processedPoints, cellSide / 2, {
                gridType: 'hex',
                property: 'value',
                units: 'kilometers'
            });

            // د. قص النتيجة (Clipping) لتظهر داخل المضلع فقط
            // نقوم بالمرور على خلايا الشبكة الناتجة وحذف ما هو خارج المضلع
            const clippedGrid = turf.featureCollection(
                interpolatedGrid.features.filter(f => turf.booleanIntersects(f, userPolygon))
            );

            // هـ. العرض على الخريطة
            drawResult(clippedGrid, variable);
            
            status.innerText = "تمت العملية بنجاح.";
            
        } catch (err) {
            console.error(err);
            status.innerText = "خطأ: " + err.message;
            status.style.color = "red";
        } finally {
            btn.disabled = false;
            loader.style.display = 'none';
        }
    }

    // 4. دالة الاتصال بـ API الأرشيف
    async function fetchHistoricalData(points, year, variable) {
        // تحديد البارامترات حسب المتغير
        // temperature_2m_mean: متوسط الحرارة اليومي
        // precipitation_sum: مجموع المطر اليومي
        const apiVar = variable === 'temp' ? 'temperature_2m_mean' : 'precipitation_sum';
        
        const promises = points.map(async (point) => {
            const [lng, lat] = point.geometry.coordinates;
            const url = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lng}&start_date=${year}-01-01&end_date=${year}-12-31&daily=${apiVar}&timezone=auto`;
            
            try {
                const res = await fetch(url);
                const data = await res.json();
                
                if (!data.daily) return null;

                const values = data.daily[apiVar];
                
                // حساب القيمة النهائية للسنة
                let finalValue = 0;
                
                if (variable === 'temp') {
                    // للحرارة: نحسب المتوسط السنوي (Average)
                    const sum = values.reduce((a, b) => a + b, 0);
                    finalValue = sum / values.length;
                } else {
                    // للأمطار: نحسب المجموع السنوي (Sum)
                    finalValue = values.reduce((a, b) => a + b, 0);
                }

                point.properties.value = finalValue;
                return point;
            } catch (e) {
                return null;
            }
        });

        const results = await Promise.all(promises);
        return turf.featureCollection(results.filter(p => p !== null));
    }

    // 5. دالة الرسم والتلوين
    function drawResult(grid, variable) {
        // حساب Min/Max للتلوين
        let min = Infinity, max = -Infinity;
        turf.featureEach(grid, (f) => {
            if (f.properties.value < min) min = f.properties.value;
            if (f.properties.value > max) max = f.properties.value;
        });

        // رسم الطبقة
        resultLayer = L.geoJSON(grid, {
            style: function(feature) {
                return {
                    fillColor: getColor(feature.properties.value, min, max, variable),
                    weight: 0, // إخفاء الحدود لجعلها تبدو متصلة
                    fillOpacity: 0.8
                };
            }
        }).addTo(map);
        
        // إظهار النتائج الرقمية
        const statsDiv = document.getElementById('resultStats');
        statsDiv.style.display = 'block';
        statsDiv.innerHTML = `<strong>نتائج سنة ${document.getElementById('yearInput').value}:</strong><br>
                              أقصى قيمة: ${max.toFixed(1)} ${variable==='temp'?'°C':'mm'}<br>
                              أدنى قيمة: ${min.toFixed(1)} ${variable==='temp'?'°C':'mm'}`;

        updateLegend(min, max, variable);
    }

    // دالة الألوان (مختلفة للحرارة وللمطر)
    function getColor(d, min, max, variable) {
        const t = (d - min) / (max - min); // Normalize 0-1
        
        if (variable === 'temp') {
            // تدرج الحرارة (أصفر -> أحمر)
            return t > 0.8 ? '#800026' : t > 0.6 ? '#BD0026' : t > 0.4 ? '#E31A1C' : t > 0.2 ? '#FC4E2A' : '#FFEDA0';
        } else {
            // تدرج الأمطار (أبيض -> أزرق غامق)
            return t > 0.8 ? '#08306b' : t > 0.6 ? '#08519c' : t > 0.4 ? '#2171b5' : t > 0.2 ? '#6baed6' : '#eff3ff';
        }
    }

    function updateLegend(min, max, variable) {
        const legend = document.getElementById('legend');
        legend.style.display = 'block';
        const unit = variable === 'temp' ? '°C' : 'mm';
        legend.innerHTML = `<strong>${variable==='temp'?'الحرارة السنوية':'التساقطات السنوية'}</strong><br>`;
        
        const steps = 5;
        for (let i = steps; i >= 0; i--) {
            const val = min + ((max - min) * (i / steps));
            const col = getColor(val, min, max, variable);
            legend.innerHTML += `<i style="background:${col}"></i> ${val.toFixed(0)} ${unit}<br>`;
        }
    }
</script>

</body>
</html>
